# Story 1.5: Onboarding Flow - Photo Upload & AI Avatar Generation

**Epic:** 1 - Foundation & Core Loop Setup
**Story Points:** 13
**Status:** ⏳ Pending

## User Story

**As a** New User,
**I want** to upload a headshot photo and have the system generate my personalized Home Avatar by merging my face with the chosen archetype body,
**so that** I have a unique visual representation in the app.

## Acceptance Criteria

1. [ ] User is prompted to upload a headshot photo during onboarding
2. [ ] Photo upload functionality (camera/gallery access) is implemented
3. [ ] The uploaded photo and selected archetype are sent to the AI service (DALL-E 3) via a secure backend function (e.g., Supabase Edge Function)
4. [ ] The AI service successfully integrates the user's face onto the Stage 1 archetype body image
5. [ ] The generated avatar image URL is received and stored in the user's profile
6. [ ] A loading indicator is shown during generation (target < 15s)
7. [ ] Basic error handling for failed generation is implemented

## Technical Requirements

### Photo Upload

**Library:** `react-native-image-picker`

**Permissions:**
- Camera access (iOS: `NSCameraUsageDescription`)
- Photo library access (iOS: `NSPhotoLibraryUsageDescription`)

**Image Constraints:**
- Min resolution: 512x512
- Max file size: 5MB
- Formats: JPEG, PNG
- Face detection validation (optional)

### AI Avatar Generation

**Service:** OpenAI `gpt-image-1` API (Image Edit endpoint)

**Edge Function:** `apps/supabase-functions/avatar-generator/index.ts`

**Workflow:**
1. User uploads headshot
2. Upload to Supabase Storage bucket `raw-headshots`
3. Call Edge Function with storage path + archetype
4. Edge Function downloads headshot from storage
5. Edge Function calls `gpt-image-1` **Image Edit API** with:
   - User's actual headshot photo as input
   - Detailed DMG pixel art style prompt
6. OpenAI applies DMG styling while preserving user's identity
7. Edge Function uploads result to `avatars` bucket
8. Update user profile with avatar URL
9. Return avatar URL to client

**Key Advantage:** Unlike `images.generate`, the **Image Edit API** can take the user's actual photo as input and apply styling transformations while preserving facial identity—solving the face-likeness challenge.

**Prompt Architecture:**
- Universal Style Template (base layer, future-proof)
- DMG Pixel Art Style Template (specific implementation)
- Identity preservation constraints
- Framing and composition rules

See `apps/supabase-functions/shared/avatarPrompts.ts` for full templates.

### Supabase Storage Buckets

1. **raw-headshots** (private)
   - Stores uploaded user headshots
   - RLS: Users can only upload/read their own photos
   - Folder structure: `{user_id}/{timestamp}.png`

2. **avatars** (public)
   - Stores AI-generated avatar images
   - Public read access for all
   - Write access via service role only (Edge Function)
   - Folder structure: `user-{user_id}/{timestamp}-dmg.png`

## Implementation Tasks

### 1. Photo Upload Screen

**File:** `apps/mobile-shell/src/screens/onboarding/PhotoUploadScreen.tsx`

```typescript
- Camera button
- Gallery button
- Preview uploaded photo
- "Generate My Avatar" button
- Loading state with progress indicator
- Error state with retry option
```

### 2. Image Service

**File:** `apps/mobile-shell/src/services/imageService.ts`

```typescript
- openCamera(): Promise<ImagePickerResponse>
- openGallery(): Promise<ImagePickerResponse>
- uploadPhoto(uri: string, userId: string): Promise<string>
- validateImage(uri: string): Promise<boolean>
```

### 3. Edge Function: avatar-generator

**File:** `apps/supabase-functions/avatar-generator/index.ts`

**Request Body:**
```json
{
  "headshot_storage_path": "user-123/1234567890.png",
  "archetype": "trainer",
  "palette_mode": "dmg",
  "regen_reason": "initial_upload"
}
```

**Workflow:**
```typescript
serve(async (req) => {
  // 1. Verify JWT and get user
  const user = await getUser(req);

  // 2. Parse request
  const { headshot_storage_path, archetype, palette_mode, regen_reason } = await req.json();

  // 3. Download headshot from Supabase Storage
  const headshotBlob = await supabaseAdmin.storage
    .from("raw-headshots")
    .download(headshot_storage_path);

  // 4. Convert to File for FormData
  const imageFile = new File([headshotBlob], "headshot.png", { type: "image/png" });

  // 5. Build DMG pixel art prompt
  const prompt = buildDmgPixelArtPrompt({ archetype, extraContext: regen_reason });

  // 6. Call gpt-image-1 Image Edit API
  const formData = new FormData();
  formData.append("model", "gpt-image-1");
  formData.append("prompt", prompt);
  formData.append("image", imageFile);
  formData.append("size", "1024x1024");
  formData.append("quality", "medium");
  formData.append("output_format", "png");
  formData.append("response_format", "b64_json");

  const openAiResponse = await callOpenAIImageEdit(formData);

  // 7. Decode base64 and upload to Supabase
  const avatarBytes = decodeBase64(openAiResponse.data[0].b64_json);
  const avatarPath = await uploadToAvatarsBucket(avatarBytes, user.id);

  // 8. Update user profile
  await updateUserProfile(user.id, { home_avatar_url: avatarPath });

  // 9. Return avatar URL
  return new Response(JSON.stringify({ status: "ok", avatar_url: avatarPath }));
});
```

### 4. Environment Variables

Add to `.env`:
```
OPENAI_API_KEY=sk-...
```

Add to Supabase Edge Function secrets:
```bash
supabase secrets set OPENAI_API_KEY=sk-...
```

## User Flow

1. User completes archetype selection (Story 1.4)
2. Navigates to photo upload screen
3. Taps "Take Photo" or "Choose from Gallery"
4. Grants camera/photo permissions
5. Selects/captures photo
6. Reviews photo preview
7. Taps "Generate My Avatar"
8. Loading screen shows (< 15s target)
9. Avatar generation complete
10. Preview generated avatar
11. Taps "Looks Great!" to continue
12. Or "Try Again" to re-generate

## Error Handling

### Permission Denied
```typescript
if (!cameraPermission) {
  showAlert("Camera access required", "Please enable camera in Settings");
}
```

### Image Too Large
```typescript
if (fileSize > MAX_FILE_SIZE) {
  showAlert("Image too large", "Please select an image under 5MB");
}
```

### Generation Failed
```typescript
try {
  const avatar = await generateAvatar(photo, archetype);
} catch (error) {
  showAlert("Generation failed", "Please try again or choose a different photo");
  logError(error);
}
```

### Rate Limiting
```typescript
// Limit to 3 generation attempts per day
if (generationAttempts >= 3) {
  showAlert("Daily limit reached", "Try again tomorrow");
}
```

## Testing

### Manual Testing
1. Test camera capture on physical device
2. Test gallery selection
3. Test with various photo qualities
4. Test with/without face in photo
5. Test all 5 archetypes
6. Verify avatar quality
7. Test retry flow

### Edge Cases
- No face detected in photo
- Multiple faces in photo
- Poor lighting
- Extreme angles
- DALL-E API timeout
- Storage upload failure

## Cost Considerations

**gpt-image-1 Pricing (Image Edit API):**
- ~$0.040 per image (1024x1024, medium quality)
- Budget: ~$100/month = 2,500 avatars
- With 3 retry limit per user per day = sustainable
- Consider caching avatars (don't regenerate on every app open)

**Future Migration:**
- When volume exceeds 10k avatars/month, migrate to Stable Diffusion + LoRA
- Self-hosted SD = fixed GPU costs (~$150/mo) vs. per-image pricing
- Implementation designed for easy swap (same Edge Function contract)

## Database Updates

```sql
-- Track avatar generation attempts
ALTER TABLE public.user_profiles
  ADD COLUMN avatar_generation_attempts INTEGER DEFAULT 0,
  ADD COLUMN avatar_generated_at TIMESTAMPTZ;
```

## Dependencies

- `react-native-image-picker` - Camera/gallery access
- OpenAI `gpt-image-1` API (Image Edit endpoint)
- Supabase Storage (raw-headshots, avatars buckets)
- Supabase Edge Functions (Deno runtime)

## Shared Utilities

- `apps/supabase-functions/shared/openaiClient.ts` - OpenAI API wrapper
- `apps/supabase-functions/shared/avatarPrompts.ts` - Prompt templates

## Next Story

**Story 1.6:** Combat Character Selection & Home Screen Display
