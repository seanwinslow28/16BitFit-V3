# Story 1.11: Achieve 60fps Performance Target

**Epic:** 1 - Foundation & Core Loop Setup
**Story Points:** 13
**Status:** ⏳ Pending

## User Story

**As a** Player,
**I want** the combat gameplay against the Training Dummy to consistently run at 60fps on target devices,
**so that** the fighting experience feels smooth and responsive.

## Acceptance Criteria

1. [ ] Performance profiling is conducted during combat scenarios (Story 1.8, 1.9) on target devices (iPhone 12+, Android 10+ equivalent)
2. [ ] Optimizations (object pooling, texture atlasing, bridge communication frequency, etc.) are implemented as needed
3. [ ] Combat achieves an average of 60fps with 90% consistency (NFR1)
4. [ ] Memory usage remains below 150MB peak (NFR3)
5. [ ] Input latency remains below 50ms (NFR2)

## Performance Targets (NFRs)

| Metric | Target | Current | Status |
|--------|--------|---------|--------|
| **Frame Rate** | 60fps (90% consistency) | TBD | ⏳ |
| **Input Latency** | < 50ms | TBD | ⏳ |
| **Memory Usage** | < 150MB peak | TBD | ⏳ |
| **Bridge Latency** | < 16ms | TBD | ⏳ |
| **App Launch** | < 3s cold start | TBD | ⏳ |

## Profiling Tools

### React Native
- **Flipper Performance Plugin**
- **React DevTools Profiler**
- **Xcode Instruments** (iOS)
- **Android Profiler** (Android)

### Phaser
- **Phaser Debug Plugin**
- **Chrome DevTools** (via WebView debugging)
- **FPS Counter overlay**

## Optimization Strategies

### 1. Phaser Optimizations

**Texture Atlasing:**
```typescript
// Combine all sprites into texture atlases
this.load.atlas('characters', 'characters.png', 'characters.json');
this.load.atlas('ui', 'ui.png', 'ui.json');

// Use TexturePacker or similar tool to generate atlases
```

**Object Pooling:**
```typescript
class DamageNumberPool {
  private pool: Phaser.GameObjects.Text[] = [];

  get(): Phaser.GameObjects.Text {
    let number = this.pool.pop();
    if (!number) {
      number = this.scene.add.text(0, 0, '', { fontSize: '24px' });
    }
    return number;
  }

  release(number: Phaser.GameObjects.Text): void {
    number.setVisible(false);
    this.pool.push(number);
  }
}
```

**Sprite Animation Optimization:**
```typescript
// Limit animation frame rate to 30fps for non-critical animations
this.anims.create({
  key: 'idle',
  frames: this.anims.generateFrameNumbers('character', { start: 0, end: 3 }),
  frameRate: 30, // Instead of 60
  repeat: -1,
});
```

**Render Optimization:**
```typescript
// Disable unnecessary render passes
this.cameras.main.setRoundPixels(true); // Pixel-perfect rendering
this.physics.world.setFPS(60); // Lock physics to 60fps

// Cull off-screen objects
this.cameras.main.setBounds(0, 0, 800, 600);
this.children.each((child) => {
  child.setScrollFactor(1); // Enable culling
});
```

### 2. Bridge Optimizations

**Throttle Messages:**
```typescript
class BridgeService {
  private messageBuffer: BridgeMessage[] = [];
  private flushInterval = 16; // 60fps = ~16ms per frame

  constructor() {
    setInterval(() => this.flush(), this.flushInterval);
  }

  send(message: BridgeMessage): void {
    this.messageBuffer.push(message);
  }

  private flush(): void {
    if (this.messageBuffer.length === 0) return;

    // Batch multiple messages into one
    const batch = this.messageBuffer.splice(0, this.messageBuffer.length);
    this.sendBatch(batch);
  }
}
```

**Binary Encoding:**
```typescript
// Instead of JSON, use binary format for high-frequency messages
function encodeInput(action: string): ArrayBuffer {
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setUint8(0, ACTION_CODES[action]);
  view.setUint32(1, Date.now());
  return buffer;
}
```

### 3. React Native Optimizations

**Memo Components:**
```typescript
export const VirtualController = React.memo(({ onInput }) => {
  // Prevent unnecessary re-renders
});
```

**Use Native Driver:**
```typescript
Animated.timing(animatedValue, {
  toValue: 1,
  duration: 200,
  useNativeDriver: true, // Critical for 60fps animations
}).start();
```

**Optimize List Rendering:**
```typescript
<FlatList
  data={items}
  renderItem={renderItem}
  keyExtractor={keyExtractor}
  removeClippedSubviews={true} // Unmount off-screen items
  maxToRenderPerBatch={10}
  windowSize={5}
/>
```

### 4. Memory Management

**Texture Cleanup:**
```typescript
class BattleScene extends Phaser.Scene {
  shutdown() {
    // Clean up textures when scene ends
    this.textures.remove('temp_background');
    this.sound.removeAll();
    this.children.removeAll(true);
  }
}
```

**WebView Memory:**
```typescript
<WebView
  source={{ uri: GAME_URL }}
  androidHardwareAccelerationDisabled={false} // Enable GPU acceleration
  androidLayerType="hardware"
  cacheEnabled={false} // Disable cache to reduce memory
/>
```

### 5. Asset Optimization

**Image Compression:**
- Use WebP format (smaller than PNG)
- Max texture size: 2048x2048
- Compress with TinyPNG or similar

**Audio Optimization:**
- Use MP3 at 128kbps (instead of WAV)
- Preload critical sounds
- Stream background music

**Bundle Size:**
- Code splitting for Phaser scenes
- Lazy load non-critical assets
- Use Webpack bundle analyzer

## Performance Monitoring

### In-Game FPS Counter

**File:** `apps/game-engine/src/utils/FPSMonitor.ts`

```typescript
export class FPSMonitor {
  private fpsText: Phaser.GameObjects.Text;
  private frames: number[] = [];

  update(): void {
    const fps = this.scene.game.loop.actualFps;
    this.frames.push(fps);

    if (this.frames.length > 60) {
      this.frames.shift();
    }

    const avgFPS = this.frames.reduce((a, b) => a + b) / this.frames.length;
    this.fpsText.setText(`FPS: ${Math.round(avgFPS)}`);

    // Warn on low FPS
    if (avgFPS < 55) {
      console.warn(`Low FPS detected: ${avgFPS}`);
    }
  }
}
```

### Latency Measurement

```typescript
function measureBridgeLatency(): void {
  const measurements: number[] = [];

  for (let i = 0; i < 100; i++) {
    const start = performance.now();

    bridge.send('PING');
    bridge.once('PONG', () => {
      const latency = performance.now() - start;
      measurements.push(latency);

      if (i === 99) {
        const avg = measurements.reduce((a, b) => a + b) / measurements.length;
        console.log(`Average bridge latency: ${avg.toFixed(2)}ms`);
      }
    });
  }
}
```

## Testing Devices

### iOS
- iPhone 12 (minimum target)
- iPhone 14 Pro
- iPad Air (for larger screen testing)

### Android
- Google Pixel 5 (Android 11+)
- Samsung Galaxy S21
- OnePlus 9 (different manufacturer)

## Automated Performance Tests

```typescript
describe('Performance Tests', () => {
  it('maintains 60fps during combat', async () => {
    const fpsReadings = await runCombatScenario(60000); // 1 minute
    const avgFPS = average(fpsReadings);
    const consistency = fpsReadings.filter(fps => fps >= 55).length / fpsReadings.length;

    expect(avgFPS).toBeGreaterThan(58);
    expect(consistency).toBeGreaterThan(0.9); // 90% at 55+ fps
  });

  it('keeps memory under 150MB', async () => {
    const initialMemory = await getMemoryUsage();
    await runCombatScenario(60000);
    const peakMemory = await getPeakMemoryUsage();

    expect(peakMemory).toBeLessThan(150 * 1024 * 1024); // 150MB
  });

  it('maintains low input latency', async () => {
    const latencies = await measureInputLatencies(100);
    const avgLatency = average(latencies);

    expect(avgLatency).toBeLessThan(50); // < 50ms
  });
});
```

## Performance Budget

| Asset Type | Budget | Notes |
|-----------|---------|-------|
| Total JS Bundle | < 2MB | Code splitting |
| Image Assets | < 5MB | Texture atlases, WebP |
| Audio Assets | < 3MB | MP3 compression |
| Total App Size | < 50MB | iOS/Android combined |

## Optimization Checklist

- [ ] Texture atlases generated and loaded
- [ ] Object pooling for frequently created objects
- [ ] Bridge message batching implemented
- [ ] Native driver used for all animations
- [ ] Sprites use correct blend modes
- [ ] Physics bodies optimized (only where needed)
- [ ] Render culling enabled
- [ ] Unnecessary re-renders eliminated
- [ ] Memory leaks checked and fixed
- [ ] Assets compressed (images, audio)
- [ ] Code minified and bundled
- [ ] Performance profiling on all target devices

## Known Performance Pitfalls

1. **Too many postMessage calls** - Batch messages
2. **Large PNG files** - Convert to WebP
3. **Unnecessary state updates** - Use React.memo
4. **Physics overhead** - Disable when not needed
5. **Texture memory** - Unload unused textures
6. **Animation frame rates** - Limit to 30fps for idle animations

## Success Criteria

✅ **Combat runs at 60fps** on iPhone 12 and Pixel 5
✅ **Input latency < 50ms** measured over 100 samples
✅ **Memory usage < 150MB** during extended play session
✅ **App launch < 3s** cold start on target devices
✅ **No frame drops** during critical moments (attacks, hits)

## Dependencies

- Stories 1.8, 1.9 (Combat implementation) complete
- Access to physical test devices
- Performance profiling tools configured

## Completion

This story marks the **end of Epic 1**. Upon completion:
- Core game loop is validated
- Technical foundation is solid
- Performance targets are met
- Ready to move to Epic 2 (Fitness Progression Integration)
